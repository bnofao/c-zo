---
github_number: 43
title: "[Epic] Architecture Microservices"
status: synced
prd: kit
trd: true
labels:
  - epic
created: 2026-02-10
updated: 2026-02-10
---

## Overview

Stratégie d'évolution de c-zo depuis un **monolithe modulaire** vers une **architecture microservices**. L'objectif n'est pas de migrer immédiatement, mais de **préparer le monolithe** (Phase 0) pour que l'extraction future de services soit naturelle et incrémentale.

La stratégie repose sur trois piliers :
1. **Abstraction EventBus** avec provider pattern (hookable pour le monolithe, RabbitMQ pour les microservices)
2. **Modèle hybride de communication** : RabbitMQ pour l'inter-service, BullMQ pour l'intra-service
3. **Migration Strangler Fig** : extraction progressive des services (Auth → Catalog → Order+Payment → reste)

> **Important :** cet epic est **préparatoire**. Aucune migration ne doit être lancée sans que les déclencheurs du framework de décision soient atteints (équipe > 5 devs, scaling indépendant nécessaire, etc.)

## Source Documents

- **PRD**: [prd-microservices.md](docs/planning/kit/prd-microservices.md)
- **TRD**: [trd-microservices.md](docs/planning/kit/trd-microservices.md)
- **Brainstorm**: [brainstorm-microservices.md](docs/planning/kit/brainstorm-microservices.md)

## User Stories

### P0 — Phase 0 : Préparer le Monolithe

- [x] #44
- [x] #45
- [x] #46

### P1 — Phase 1-2 : Premières Extractions

- [ ] **API Gateway (GraphQL Federation)** — En tant que client frontend, je veux continuer à envoyer mes requêtes GraphQL à un seul endpoint, même si les services backend sont distribués
- [ ] **Extraction Auth Service** — En tant qu'architecte, je veux extraire l'auth en service standalone pour isoler les données sensibles et permettre un scaling indépendant
- [ ] **Extraction Catalog Service** — En tant qu'architecte, je veux extraire le catalogue (Product + Attribute + Channel) en service standalone pour le scaler indépendamment

### P2 — Phase 3+ : Extraction Complète

- [ ] **Order + Payment Services** — Saga pattern pour transactions distribuées (Order → Payment → Inventory)
- [ ] **Inventory, Search, Notification Services** — Services asynchrones, consumers d'events
- [ ] #47

## Acceptance Criteria

- [ ] L'abstraction EventBus est implémentée avec providers hookable et RabbitMQ
- [ ] 100% des events passent par `EventBus.publish()` (aucun `emit()` hookable direct)
- [ ] Le schema `DomainEvent<T>` est adopté pour tous les events
- [ ] RabbitMQ tourne en local via Docker Compose
- [ ] Le mode dual-write (hookable + RabbitMQ) fonctionne sans perte de messages
- [ ] Couverture tests >= 80% sur le code EventBus
- [ ] Framework de décision documenté avec déclencheurs et anti-patterns

## Architecture — Modèle Hybride

```
INTER-SERVICE (Events de domaine)     INTRA-SERVICE (Background jobs)
┌──────────────┐                      ┌──────────────┐
│  RabbitMQ    │                      │   BullMQ     │
│  - Exchanges │                      │   (+ Redis)  │
│  - Routing   │                      │  - Job queue │
│  - Fan-out   │                      │  - Workers   │
│  - DLX       │                      │  - Cron      │
└──────────────┘                      └──────────────┘
```

## Notes

- **Phase 0 est la seule phase immédiatement actionnable** — les phases 1+ sont conditionnées aux déclencheurs
- Le provider pattern est aligné avec le design existant de `brainstorm-tasks.md`
- RabbitMQ topology : 1 topic exchange (`czo.events`), 1 fanout (`czo.system`), 1 DLX (`czo.dlx`)
- Convention routing keys : `<domaine>.<entité>.<action>` (ex: `product.item.created`)
- Ordre d'extraction prévu : Auth → Catalog → Order+Payment → Inventory/Search/Notification → App
