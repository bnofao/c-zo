"""Generic boolean response payload"""
type BooleanPayload {
  """Optional message"""
  message: String

  """Operation success status"""
  success: Boolean!
}

"""Category tree node with nested children"""
type CategoryNode {
  category: ProductCategory!
  children: [CategoryNode!]!
  depth: Int!
}

"""Category mutation response payload"""
type CategoryPayload {
  category: ProductCategory
  errors: [Error!]
}

type CollectionPayload {
  collection: ProductCollection
  errors: [Error!]
}

"""Input for creating a new category"""
input CreateCategoryInput {
  description: String = ""
  handle: String
  imageId: String
  isActive: Boolean = false
  isInternal: Boolean = false
  metadata: JSON
  name: String!
  parentId: ID
  rank: Int = 0
  thumbnail: String
}

input CreateCollectionInput {
  handle: String
  metadata: JSON
  title: String!
}

"""Input for creating a new product"""
input CreateProductInput {
  collectionId: ID
  description: String
  discountable: Boolean = true
  externalId: String
  handle: String
  height: String
  hsCode: String
  isGiftcard: Boolean = false
  length: String
  material: String
  metadata: JSON
  midCode: String
  originCountry: String
  status: ProductStatus = DRAFT
  subtitle: String
  thumbnail: String
  title: String!
  typeId: ID
  weight: String
  width: String
}

input CreateProductOptionInput {
  title: String!
  values: [String!]!
}

"""Input for creating a new variant"""
input CreateVariantInput {
  allowBackorder: Boolean = false
  barcode: String
  ean: String
  height: Int
  hsCode: String
  length: Int
  manageInventory: Boolean = true
  material: String
  metadata: JSON
  midCode: String
  originCountry: String
  sku: String
  thumbnail: String
  title: String!
  upc: String
  variantRank: Int = 0
  weight: Int
  width: Int
}

"""Custom scalar for DateTime values (ISO 8601 format)"""
scalar DateTime

"""Generic delete response payload"""
type DeletePayload {
  """Timestamp when the record was deleted"""
  deletedAt: DateTime!

  """Optional message"""
  message: String

  """Whether the deletion was successful"""
  success: Boolean!
}

"""Error type for mutation responses"""
type Error {
  """Machine-readable error code"""
  code: String!

  """Field that caused the error (if applicable)"""
  field: String

  """Human-readable error message"""
  message: String!
}

type ImagePayload {
  errors: [Error!]
  image: ProductImage
}

"""Custom scalar for JSON data"""
scalar JSON

type Mutation {
  addOptionValue(optionId: ID!, value: String!): OptionValuePayload!

  """Assign a product to multiple categories"""
  assignProductToCategories(categoryIds: [ID!]!, productId: ID!): ProductPayload!
  assignTagsToProduct(productId: ID!, tagIds: [ID!]!): ProductPayload!
  associateImageWithVariant(imageId: ID!, variantId: ID!): BooleanPayload!
  associateVariantOptions(optionValueIds: [ID!]!, variantId: ID!): VariantPayload!

  """Create a new category"""
  createCategory(input: CreateCategoryInput!): CategoryPayload!
  createCollection(input: CreateCollectionInput!): CollectionPayload!

  """Create a new product"""
  createProduct(input: CreateProductInput!): ProductPayload!
  createProductOption(productId: ID!, title: String!, values: [String!]!): OptionPayload!
  createProductType(metadata: JSON, value: String!): TypePayload!

  """Create a new product variant"""
  createProductVariant(input: CreateVariantInput!, productId: ID!): VariantPayload!
  createTag(value: String!): TagPayload!

  """Soft-delete a category"""
  deleteCategory(id: ID!): DeletePayload!
  deleteCollection(id: ID!): DeletePayload!
  deleteOptionValue(id: ID!): DeletePayload!

  """Soft-delete a product"""
  deleteProduct(id: ID!): DeletePayload!
  deleteProductImage(id: ID!): DeletePayload!
  deleteProductType(id: ID!): DeletePayload!

  """Soft-delete a variant"""
  deleteProductVariant(id: ID!): DeletePayload!
  deleteTag(id: ID!): DeletePayload!

  """Update an existing category"""
  updateCategory(id: ID!, input: UpdateCategoryInput!): CategoryPayload!
  updateCollection(id: ID!, input: UpdateCollectionInput!): CollectionPayload!

  """Update an existing product"""
  updateProduct(id: ID!, input: UpdateProductInput!): ProductPayload!
  updateProductType(id: ID!, metadata: JSON, value: String): TypePayload!

  """Update an existing variant"""
  updateProductVariant(id: ID!, input: UpdateVariantInput!): VariantPayload!
  uploadProductImage(metadata: JSON, productId: ID!, rank: Int, url: String!): ImagePayload!
}

type OptionPayload {
  errors: [Error!]
  option: ProductOption
  values: [ProductOptionValue!]
}

type OptionValuePayload {
  errors: [Error!]
  optionValue: ProductOptionValue
}

"""Page information for cursor-based pagination"""
type PageInfo {
  """Cursor for the last item in this page"""
  endCursor: String

  """Whether there are more items after this page"""
  hasNextPage: Boolean!

  """Whether there are items before this page"""
  hasPreviousPage: Boolean!

  """Cursor for the first item in this page"""
  startCursor: String
}

"""Pagination input for list queries"""
input PaginationInput {
  """Cursor for cursor-based pagination"""
  cursor: String

  """Number of items to return (max 100)"""
  limit: Int = 50

  """Number of items to skip"""
  offset: Int = 0
}

"""Core product entity representing a marketplace item"""
type Product {
  categories: [ProductCategory!]!
  collection: ProductCollection
  createdAt: DateTime!
  description: String
  discountable: Boolean!
  externalId: String
  handle: String!
  height: String
  hsCode: String
  id: ID!
  images: [ProductImage!]!
  isGiftcard: Boolean!
  length: String
  material: String
  metadata: JSON
  midCode: String
  options: [ProductOption!]!
  originCountry: String
  status: ProductStatus!
  subtitle: String
  tags: [ProductTag!]!
  thumbnail: String
  title: String!
  type: ProductType
  updatedAt: DateTime!
  variants: [ProductVariant!]!
  weight: String
  width: String
}

"""Hierarchical product category using adjacency list pattern"""
type ProductCategory {
  children: [ProductCategory!]!
  createdAt: DateTime!
  description: String!
  handle: String!
  id: ID!
  image: ProductImage
  isActive: Boolean!
  isInternal: Boolean!
  metadata: JSON
  name: String!
  parent: ProductCategory
  products: [Product!]!
  rank: Int!
  thumbnail: String
  updatedAt: DateTime!
}

type ProductCollection {
  createdAt: DateTime!
  handle: String!
  id: ID!
  metadata: JSON
  products: [Product!]!
  title: String!
  updatedAt: DateTime!
}

"""Product connection for pagination"""
type ProductConnection {
  nodes: [Product!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

"""Product filter input for list queries"""
input ProductFilter {
  collectionId: ID
  discountable: Boolean
  isGiftcard: Boolean
  search: String
  status: ProductStatus
  typeId: ID
}

type ProductImage {
  createdAt: DateTime!
  id: ID!
  metadata: JSON
  product: Product!
  rank: Int!
  updatedAt: DateTime!
  url: String!
  variants: [ProductVariant!]!
}

"""Product option defining a variant dimension (e.g., Color, Size)"""
type ProductOption {
  createdAt: DateTime!
  id: ID!
  metadata: JSON
  product: Product!
  title: String!
  updatedAt: DateTime!
  values: [ProductOptionValue!]!
}

"""Specific value for a product option (e.g., "Red" for Color)"""
type ProductOptionValue {
  createdAt: DateTime!
  id: ID!
  metadata: JSON
  option: ProductOption!
  updatedAt: DateTime!
  value: String!
  variants: [ProductVariant!]!
}

"""Product mutation response payload"""
type ProductPayload {
  errors: [Error!]
  product: Product
}

"""Product sort options"""
input ProductSort {
  direction: SortDirection = ASC
  field: ProductSortField!
}

enum ProductSortField {
  CREATED_AT
  STATUS
  TITLE
  UPDATED_AT
}

"""Product status enum"""
enum ProductStatus {
  DRAFT
  PROPOSED
  PUBLISHED
  REJECTED
}

type ProductTag {
  createdAt: DateTime!
  id: ID!
  metadata: JSON
  products: [Product!]!
  updatedAt: DateTime!
  value: String!
}

type ProductType {
  createdAt: DateTime!
  id: ID!
  metadata: JSON
  products: [Product!]!
  updatedAt: DateTime!
  value: String!
}

"""Product variant representing a specific variation of a product"""
type ProductVariant {
  allowBackorder: Boolean!
  barcode: String
  createdAt: DateTime!
  ean: String
  height: Int
  hsCode: String
  id: ID!
  images: [ProductImage!]!
  length: Int
  manageInventory: Boolean!
  material: String
  metadata: JSON
  midCode: String
  optionValues: [ProductOptionValue!]!
  originCountry: String
  product: Product!
  sku: String
  thumbnail: String
  title: String!
  upc: String
  updatedAt: DateTime!
  variantRank: Int!
  weight: Int
  width: Int
}

type Query {
  """Get a single category by ID"""
  category(id: ID!): ProductCategory

  """Get category tree starting from a root (or all roots if not specified)"""
  categoryTree(rootCategoryId: ID): [CategoryNode!]!
  collection(id: ID!): ProductCollection

  """Get a single product by ID"""
  product(id: ID!): Product
  productOptions(productId: ID!): [ProductOption!]!
  productType(id: ID!): ProductType
  productTypes: [ProductType!]!

  """List products with filtering and pagination"""
  products(filter: ProductFilter, pagination: PaginationInput, sort: ProductSort): ProductConnection!
  productsByCollection(collectionId: ID!, pagination: PaginationInput): ProductConnection!
  tag(id: ID!): ProductTag
  tags(filter: TagFilter): [ProductTag!]!

  """Get a single variant by ID"""
  variant(id: ID!): ProductVariant
}

"""Sort direction enum"""
enum SortDirection {
  ASC
  DESC
}

input TagFilter {
  search: String
  value: String
}

type TagPayload {
  errors: [Error!]
  tag: ProductTag
}

type TypePayload {
  errors: [Error!]
  type: ProductType
}

"""Input for updating an existing category"""
input UpdateCategoryInput {
  description: String
  expectedUpdatedAt: DateTime!
  handle: String
  imageId: String
  isActive: Boolean
  isInternal: Boolean
  metadata: JSON
  name: String
  parentId: ID
  rank: Int
  thumbnail: String
}

input UpdateCollectionInput {
  expectedUpdatedAt: DateTime!
  handle: String
  metadata: JSON
  title: String
}

"""Input for updating an existing product"""
input UpdateProductInput {
  collectionId: ID
  description: String
  discountable: Boolean
  expectedUpdatedAt: DateTime!
  externalId: String
  height: String
  hsCode: String
  length: String
  material: String
  metadata: JSON
  midCode: String
  originCountry: String
  status: ProductStatus
  subtitle: String
  thumbnail: String
  title: String
  typeId: ID
  weight: String
  width: String
}

"""Input for updating an existing variant"""
input UpdateVariantInput {
  allowBackorder: Boolean
  barcode: String
  ean: String
  expectedUpdatedAt: DateTime!
  height: Int
  hsCode: String
  length: Int
  manageInventory: Boolean
  material: String
  metadata: JSON
  midCode: String
  originCountry: String
  sku: String
  thumbnail: String
  title: String
  upc: String
  variantRank: Int
  weight: Int
  width: Int
}

"""Variant mutation response payload"""
type VariantPayload {
  errors: [Error!]
  variant: ProductVariant
}